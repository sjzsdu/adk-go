# ADK-Go API 参考

## 1. 概述

本文档提供了 ADK-Go 框架的核心 API 参考，包括主要接口、结构体、函数和方法。API 按照包或模块组织，便于查阅和使用。

## 2. agent 包

### 2.1 概述

`agent` 包定义了代理框架的核心接口和类型，是 ADK-Go 框架的基础。

### 2.2 Agent 接口

```go
type Agent interface {
    Name() string
    Description() string
    Run(InvocationContext) iter.Seq2[*Event, error]
    SubAgents() []Agent
    internal() *agent
}
```

**描述**：
Agent 接口是所有代理的基本抽象，定义了代理的核心行为。

**方法说明**：
- `Name() string`：返回代理的名称
- `Description() string`：返回代理的描述
- `Run(InvocationContext) iter.Seq2[*Event, error]`：运行代理，接收上下文并返回事件迭代器
- `SubAgents() []Agent`：返回代理的子代理列表
- `internal() *agent`：返回内部代理实现（内部使用）

### 2.3 InvocationContext 接口

```go
type InvocationContext interface {
    Done() context.Context
    Agent() Agent
    Session() session.Session
    Artifacts() artifact.Service
    Memory() memory.Service
    UserContent() *genai.Content
    RunConfig() RunConfig
    Branch() string
    InvocationID() string
    NewInvocationID() string
}
```

**描述**：
InvocationContext 提供了代理运行时的上下文信息。

**方法说明**：
- `Done() context.Context`：返回上下文的 done 通道
- `Agent() Agent`：返回当前代理
- `Session() session.Session`：返回当前会话
- `Artifacts() artifact.Service`：返回制品服务
- `Memory() memory.Service`：返回内存服务
- `UserContent() *genai.Content`：返回用户内容
- `RunConfig() RunConfig`：返回运行配置
- `Branch() string`：返回当前分支
- `InvocationID() string`：返回当前调用 ID
- `NewInvocationID() string`：生成新的调用 ID

### 2.4 RunConfig 结构体

```go
type RunConfig struct {
    // MaxTokens limits the maximum number of tokens generated by the agent.
    MaxTokens int
    // Temperature controls the randomness of the generated output.
    Temperature float64
    // TopP controls the diversity of the generated output.
    TopP float64
    // TopK controls the diversity of the generated output.
    TopK int
}
```

**描述**：
RunConfig 定义了代理运行时的配置参数。

### 2.5 New 函数

```go
func New(cfg Config) (Agent, error)
```

**描述**：
创建一个新的自定义代理。

**参数**：
- `cfg`：代理配置

**返回值**：
- `Agent`：创建的代理
- `error`：可能的错误

### 2.6 Config 结构体

```go
type Config struct {
    // Name is the name of the agent.
    Name string
    // Description is the description of the agent.
    Description string
    // SubAgents is a list of sub-agents that this agent can use.
    SubAgents []Agent
    // Run is the function that implements the agent's behavior.
    Run func(InvocationContext) iter.Seq2[*Event, error]
    // BeforeAgentCallbacks are callbacks that are called before the agent runs.
    BeforeAgentCallbacks []BeforeAgentCallback
    // AfterAgentCallbacks are callbacks that are called after the agent runs.
    AfterAgentCallbacks []AfterAgentCallback
}
```

**描述**：
Config 用于配置代理的创建。

## 3. agent/llmagent 包

### 3.1 概述

`llmagent` 包提供了基于 LLM（大语言模型）的代理实现。

### 3.2 New 函数

```go
func New(cfg Config) (agent.Agent, error)
```

**描述**：
创建一个新的 LLM 代理。

**参数**：
- `cfg`：LLM 代理配置

**返回值**：
- `agent.Agent`：创建的 LLM 代理
- `error`：可能的错误

### 3.3 Config 结构体

```go
type Config struct {
    // Basic agent configuration.
    agent.Config
    // Model is the name of the LLM model to use.
    Model string
    // Instruction is the system instruction for the LLM.
    Instruction string
    // Tools are the tools that the agent can use.
    Tools []tool.Tool
    // Temperature controls the randomness of the generated output.
    Temperature float64
    // TopP controls the diversity of the generated output.
    TopP float64
    // TopK controls the diversity of the generated output.
    TopK int
    // MaxTokens limits the maximum number of tokens generated by the model.
    MaxTokens int
    // BeforeModelCallbacks are callbacks that are called before the model is invoked.
    BeforeModelCallbacks []BeforeModelCallback
    // AfterModelCallbacks are callbacks that are called after the model is invoked.
    AfterModelCallbacks []AfterModelCallback
    // BeforeToolCallbacks are callbacks that are called before a tool is invoked.
    BeforeToolCallbacks []BeforeToolCallback
    // AfterToolCallbacks are callbacks that are called after a tool is invoked.
    AfterToolCallbacks []AfterToolCallback
}
```

**描述**：
Config 用于配置 LLM 代理的创建。

## 4. agent/workflowagents 包

### 4.1 概述

`workflowagents` 包提供了多种工作流代理实现，用于编排多个子代理的执行。

### 4.2 sequentialagent 子包

#### 4.2.1 New 函数

```go
func New(cfg Config) (agent.Agent, error)
```

**描述**：
创建一个新的顺序代理，按顺序执行其子代理。

**参数**：
- `cfg`：顺序代理配置

**返回值**：
- `agent.Agent`：创建的顺序代理
- `error`：可能的错误

#### 4.2.2 Config 结构体

```go
type Config struct {
    // Basic agent configuration.
    agent.Config
}
```

**描述**：
Config 用于配置顺序代理的创建。

### 4.3 parallelagent 子包

#### 4.3.1 New 函数

```go
func New(cfg Config) (agent.Agent, error)
```

**描述**：
创建一个新的并行代理，并行执行其子代理。

**参数**：
- `cfg`：并行代理配置

**返回值**：
- `agent.Agent`：创建的并行代理
- `error`：可能的错误

#### 4.3.2 Config 结构体

```go
type Config struct {
    // Basic agent configuration.
    agent.Config
}
```

**描述**：
Config 用于配置并行代理的创建。

### 4.4 loopagent 子包

#### 4.4.1 New 函数

```go
func New(cfg Config) (agent.Agent, error)
```

**描述**：
创建一个新的循环代理，循环执行其子代理。

**参数**：
- `cfg`：循环代理配置

**返回值**：
- `agent.Agent`：创建的循环代理
- `error`：可能的错误

#### 4.4.2 Config 结构体

```go
type Config struct {
    // Basic agent configuration.
    agent.Config
    // MaxIterations limits the maximum number of iterations.
    // If MaxIterations == 0, then LoopAgent runs indefinitely or until any sub-agent escalates.
    MaxIterations uint
}
```

**描述**：
Config 用于配置循环代理的创建。

## 5. agent/remoteagent 包

### 5.1 概述

`remoteagent` 包提供了远程代理的实现，支持 A2A（Agent-to-Agent）协议。

### 5.2 A2AConfig 结构体

```go
type A2AConfig struct {
    // Basic agent configuration.
    agent.Config
    // AgentCard is the agent card for the remote agent.
    AgentCard *a2a.AgentCard
    // AgentCardSource is the source of the agent card.
    AgentCardSource string
    // Converter is used to convert between ADK events and A2A events.
    Converter A2AEventConverter
    // AfterRequestCallbacks are called after receiving a response from the remote agent.
    AfterRequestCallbacks []AfterA2ARequestCallback
    // AfterAgentCallbacks are called after the agent has completed its run.
    AfterAgentCallbacks []agent.AfterAgentCallback
    // ClientFactory is used to create A2A clients.
    ClientFactory *a2aclient.Factory
    // MessageSendConfig is attached to a2a.MessageSendParams sent on every agent invocation.
    MessageSendConfig *a2a.MessageSendConfig
}
```

**描述**：
A2AConfig 用于配置远程代理的创建。

### 5.3 NewA2A 函数

```go
func NewA2A(cfg A2AConfig) (agent.Agent, error)
```

**描述**：
创建一个新的远程 A2A 代理。

**参数**：
- `cfg`：A2A 代理配置

**返回值**：
- `agent.Agent`：创建的 A2A 代理
- `error`：可能的错误

## 6. runner 包

### 6.1 概述

`runner` 包提供了代理运行器的实现，负责代理的生命周期管理、会话管理和事件处理。

### 6.2 Runner 结构体

```go
type Runner struct {
    // 内部字段，不直接暴露给用户
}
```

**描述**：
Runner 是代理的运行和管理器。

### 6.3 New 函数

```go
func New(cfg Config) (*Runner, error)
```

**描述**：
创建一个新的运行器。

**参数**：
- `cfg`：运行器配置

**返回值**：
- `*Runner`：创建的运行器
- `error`：可能的错误

### 6.4 Config 结构体

```go
type Config struct {
    // AppName is the name of the application.
    AppName string
    // RootAgent is the root agent for the runner.
    RootAgent agent.Agent
    // SessionService is the session service to use.
    SessionService session.Service
    // ArtifactService is the artifact service to use.
    ArtifactService artifact.Service
    // MemoryService is the memory service to use.
    MemoryService memory.Service
    // Monitor is the monitor to use for collecting metrics.
    Monitor monitor.Monitor
}
```

**描述**：
Config 用于配置运行器的创建。

### 6.5 Run 方法

```go
func (r *Runner) Run(ctx context.Context, userID string, sessionID string, content *genai.Content, cfg *agent.RunConfig) iter.Seq2[*Event, error]
```

**描述**：
运行代理，处理用户请求并返回事件迭代器。

**参数**：
- `ctx`：上下文
- `userID`：用户 ID
- `sessionID`：会话 ID
- `content`：用户内容
- `cfg`：代理运行配置

**返回值**：
- `iter.Seq2[*Event, error]`：事件迭代器

## 7. session 包

### 7.1 概述

`session` 包提供了会话管理的实现，用于管理代理与用户的交互会话。

### 7.2 Session 接口

```go
type Session interface {
    ID() string
    UserID() string
    State() map[string]any
    SetState(map[string]any)
    AddEvent(*Event)
    Events() []*Event
    CreatedAt() time.Time
    UpdatedAt() time.Time
}
```

**描述**：
Session 接口定义了会话的核心行为。

**方法说明**：
- `ID() string`：返回会话 ID
- `UserID() string`：返回用户 ID
- `State() map[string]any`：返回会话状态
- `SetState(map[string]any)`：设置会话状态
- `AddEvent(*Event)`：添加事件到会话
- `Events() []*Event`：返回会话事件列表
- `CreatedAt() time.Time`：返回会话创建时间
- `UpdatedAt() time.Time`：返回会话更新时间

### 7.3 Event 结构体

```go
type Event struct {
    ID           string
    Content      *genai.Content
    Author       string
    Timestamp    time.Time
    Actions      Actions
    ArtifactIDs  []string
    InvocationID string
    Branch       string
    Parent       string
}
```

**描述**：
Event 表示会话中的一个事件。

### 7.4 Actions 结构体

```go
type Actions struct {
    Escalate bool
    Transfer string
    Final    bool
    Error    string
}
```

**描述**：
Actions 表示事件的操作。

### 7.5 Service 接口

```go
type Service interface {
    Create(ctx context.Context, userID string, state map[string]any) (Session, error)
    Get(ctx context.Context, sessionID string) (Session, error)
    Save(ctx context.Context, session Session) error
    Delete(ctx context.Context, sessionID string) error
    List(ctx context.Context, userID string, filter ListFilter) ([]Session, error)
}
```

**描述**：
Service 接口定义了会话服务的核心行为。

**方法说明**：
- `Create(ctx context.Context, userID string, state map[string]any) (Session, error)`：创建会话
- `Get(ctx context.Context, sessionID string) (Session, error)`：获取会话
- `Save(ctx context.Context, session Session) error`：保存会话
- `Delete(ctx context.Context, sessionID string) error`：删除会话
- `List(ctx context.Context, userID string, filter ListFilter) ([]Session, error)`：列出会话

## 8. tool 包

### 8.1 概述

`tool` 包提供了工具系统的实现，用于扩展代理的能力。

### 8.2 Tool 接口

```go
type Tool interface {
    Name() string
    Description() string
    IsLongRunning() bool
    Invoke(ctx context.Context, args json.RawMessage) (any, error)
}
```

**描述**：
Tool 接口定义了工具的核心行为。

**方法说明**：
- `Name() string`：返回工具名称
- `Description() string`：返回工具描述
- `IsLongRunning() bool`：返回工具是否为长时间运行的任务
- `Invoke(ctx context.Context, args json.RawMessage) (any, error)`：调用工具，接收上下文和参数，返回结果和可能的错误

### 8.3 NewTool 函数

```go
func NewTool(cfg ToolConfig) Tool
```

**描述**：
创建一个新的工具。

**参数**：
- `cfg`：工具配置

**返回值**：
- `Tool`：创建的工具

### 8.4 ToolConfig 结构体

```go
type ToolConfig struct {
    // Name is the name of the tool.
    Name string
    // Description is the description of the tool.
    Description string
    // IsLongRunning indicates whether the tool is long-running.
    IsLongRunning bool
    // Invoke is the function that implements the tool's behavior.
    Invoke func(ctx context.Context, args json.RawMessage) (any, error)
}
```

**描述**：
ToolConfig 用于配置工具的创建。

## 9. artifact 包

### 9.1 概述

`artifact` 包提供了制品服务的实现，用于管理代理生成和使用的制品。

### 9.2 Service 接口

```go
type Service interface {
    Create(ctx context.Context, artifact *Artifact) (*Artifact, error)
    Get(ctx context.Context, id string) (*Artifact, error)
    List(ctx context.Context, filter Filter) ([]*Artifact, error)
    Update(ctx context.Context, artifact *Artifact) (*Artifact, error)
    Delete(ctx context.Context, id string) error
}
```

**描述**：
Service 接口定义了制品服务的核心行为。

**方法说明**：
- `Create(ctx context.Context, artifact *Artifact) (*Artifact, error)`：创建制品
- `Get(ctx context.Context, id string) (*Artifact, error)`：获取制品
- `List(ctx context.Context, filter Filter) ([]*Artifact, error)`：列出制品
- `Update(ctx context.Context, artifact *Artifact) (*Artifact, error)`：更新制品
- `Delete(ctx context.Context, id string) error`：删除制品

### 9.3 Artifact 结构体

```go
type Artifact struct {
    ID          string
    Name        string
    Type        string
    Content     []byte
    SessionID   string
    UserID      string
    CreatedAt   time.Time
    UpdatedAt   time.Time
    Metadata    map[string]any
}
```

**描述**：
Artifact 表示一个制品。

### 9.4 Filter 结构体

```go
type Filter struct {
    SessionID string
    UserID    string
    Type      string
    Name      string
}
```

**描述**：
Filter 用于过滤制品列表。

## 10. memory 包

### 10.1 概述

`memory` 包提供了内存服务的实现，用于管理代理的内存。

### 10.2 Service 接口

```go
type Service interface {
    Write(ctx context.Context, memory *Memory) (*Memory, error)
    Read(ctx context.Context, id string) (*Memory, error)
    Query(ctx context.Context, query string) ([]*Memory, error)
    Delete(ctx context.Context, id string) error
}
```

**描述**：
Service 接口定义了内存服务的核心行为。

**方法说明**：
- `Write(ctx context.Context, memory *Memory) (*Memory, error)`：写入内存
- `Read(ctx context.Context, id string) (*Memory, error)`：读取内存
- `Query(ctx context.Context, query string) ([]*Memory, error)`：查询内存
- `Delete(ctx context.Context, id string) error`：删除内存

### 10.3 Memory 结构体

```go
type Memory struct {
    ID          string
    Type        string
    Content     string
    SessionID   string
    UserID      string
    CreatedAt   time.Time
    UpdatedAt   time.Time
    Metadata    map[string]any
}
```

**描述**：
Memory 表示一个内存条目。

## 11. server 包

### 11.1 概述

`server` 包提供了服务器实现，用于暴露代理服务。

### 11.2 rest 子包

#### 11.2.1 New 函数

```go
func New(runner *runner.Runner) *Server
```

**描述**：
创建一个新的 REST 服务器。

**参数**：
- `runner`：代理运行器

**返回值**：
- `*Server`：创建的 REST 服务器

#### 11.2.2 Server 结构体

```go
type Server struct {
    // 内部字段，不直接暴露给用户
}
```

**描述**：
Server 表示 REST 服务器。

#### 11.2.3 Run 方法

```go
func (s *Server) Run(cfg RunConfig) error
```

**描述**：
运行 REST 服务器。

**参数**：
- `cfg`：服务器运行配置

**返回值**：
- `error`：可能的错误

#### 11.2.4 RunConfig 结构体

```go
type RunConfig struct {
    // Port is the port to listen on.
    Port int
    // TLSConfig is the TLS configuration to use.
    TLSConfig *tls.Config
}
```

**描述**：
RunConfig 用于配置 REST 服务器的运行。

#### 11.2.5 AddHealthCheckHandler 方法

```go
func (s *Server) AddHealthCheckHandler(path string, check func() bool)
```

**描述**：
添加健康检查端点。

**参数**：
- `path`：健康检查路径
- `check`：健康检查函数

## 12. model 包

### 12.1 概述

`model` 包提供了 LLM 模型的集成，用于连接和使用各种 LLM 模型。

### 12.2 LLM 接口

```go
type LLM interface {
    Generate(ctx context.Context, req *GenerateRequest) (*GenerateResponse, error)
}
```

**描述**：
LLM 接口定义了 LLM 模型的核心行为。

**方法说明**：
- `Generate(ctx context.Context, req *GenerateRequest) (*GenerateResponse, error)`：生成文本

### 12.3 GenerateRequest 结构体

```go
type GenerateRequest struct {
    Content      *genai.Content
    Temperature  float64
    TopP         float64
    TopK         int
    MaxTokens    int
    Tools        []tool.Tool
    ToolChoice   any
}
```

**描述**：
GenerateRequest 表示生成请求。

### 12.4 GenerateResponse 结构体

```go
type GenerateResponse struct {
    Content      *genai.Content
    Usage        Usage
    ToolCalls    []ToolCall
    FinishReason string
}
```

**描述**：
GenerateResponse 表示生成响应。

### 12.5 Usage 结构体

```go
type Usage struct {
    PromptTokens     int
    CompletionTokens int
    TotalTokens      int
}
```

**描述**：
Usage 表示模型使用情况。

### 12.6 ToolCall 结构体

```go
type ToolCall struct {
    Name      string
    Args      json.RawMessage
    ID        string
    Type      string
    Thought   string
}
```

**描述**：
ToolCall 表示工具调用。

## 13. tool/builtintools 包

### 13.1 概述

`builtintools` 包提供了一些内置工具的实现，用于扩展代理的能力。

### 13.2 Calculator 工具

#### 13.2.1 NewCalculator 函数

```go
func NewCalculator() tool.Tool
```

**描述**：
创建一个新的计算器工具。

**返回值**：
- `tool.Tool`：创建的计算器工具

### 13.3 FileSystem 工具

#### 13.3.1 NewFileSystem 函数

```go
func NewFileSystem(basePath string) tool.Tool
```

**描述**：
创建一个新的文件系统工具。

**参数**：
- `basePath`：基础路径

**返回值**：
- `tool.Tool`：创建的文件系统工具

### 13.4 HTTP 工具

#### 13.4.1 NewHTTP 函数

```go
func NewHTTP() tool.Tool
```

**描述**：
创建一个新的 HTTP 工具。

**返回值**：
- `tool.Tool`：创建的 HTTP 工具

## 14. 示例代码

### 14.1 创建和运行 LLM 代理

```go
// 创建 LLM 代理
llmAgent, err := llmagent.New(llmagent.Config{
    Name:        "llm-assistant",
    Description: "A helpful LLM assistant",
    Model:       "gemini-1.5-pro",
    Instruction: "You are a helpful assistant.",
})
if err != nil {
    panic(err)
}

// 创建运行器
runner, err := runner.New(runner.Config{
    AppName:   "my-app",
    RootAgent: llmAgent,
})
if err != nil {
    panic(err)
}

// 运行代理
content := genai.NewContentFromText("Hello, world!")
for event, err := range runner.Run(context.Background(), "user-123", "session-456", content, nil) {
    if err != nil {
        panic(err)
    }
    fmt.Printf("Event: %v\n", event)
}
```

### 14.2 创建和运行工作流代理

```go
// 创建多个子代理
agent1, _ := llmagent.New(llmagent.Config{Name: "agent-1", Model: "gemini-1.5-pro"})
agent2, _ := llmagent.New(llmagent.Config{Name: "agent-2", Model: "gemini-1.5-pro"})
agent3, _ := llmagent.New(llmagent.Config{Name: "agent-3", Model: "gemini-1.5-pro"})

// 创建顺序代理
sequentialAgent, _ := sequentialagent.New(sequentialagent.Config{
    AgentConfig: agent.Config{
        Name:      "sequential-agent",
        SubAgents: []agent.Agent{agent1, agent2, agent3},
    },
})

// 创建运行器
runner, _ := runner.New(runner.Config{AppName: "my-app", RootAgent: sequentialAgent})

// 运行代理
content := genai.NewContentFromText("Hello, workflow!")
for event, err := range runner.Run(context.Background(), "user-123", "session-456", content, nil) {
    if err != nil {
        panic(err)
    }
    fmt.Printf("Event: %v\n", event)
}
```

### 14.3 创建和使用自定义工具

```go
// 创建自定义工具
calculatorTool := &CalculatorTool{}

// 创建带有工具的 LLM 代理
llmAgent, _ := llmagent.New(llmagent.Config{
    Name:        "llm-assistant-with-tools",
    Model:       "gemini-1.5-pro",
    Instruction: "You are a helpful assistant. Use the calculator tool for arithmetic operations.",
    Tools:       []tool.Tool{calculatorTool},
})

// 创建运行器
runner, _ := runner.New(runner.Config{AppName: "my-app", RootAgent: llmAgent})

// 运行代理
content := genai.NewContentFromText("What is 2 + 2?")
for event, err := range runner.Run(context.Background(), "user-123", "session-456", content, nil) {
    if err != nil {
        panic(err)
    }
    fmt.Printf("Event: %v\n", event)
}
```

## 15. 类型定义

### 15.1 iter.Seq2 类型

```go
type Seq2[T1, T2 any] func(func(T1, T2) bool)
```

**描述**：
Seq2 是 Go 1.23 引入的迭代器类型，用于表示返回两个值的序列。

### 15.2 genai.Content 类型

```go
type Content struct {
    Parts []Part
    Role  string
}
```

**描述**：
Content 表示生成式 AI 的内容，包含多个部分和角色信息。

### 15.3 genai.Part 类型

```go
type Part interface {
    // 内部方法，不直接暴露给用户
}
```

**描述**：
Part 表示内容的一个部分，可以是文本、图像、文件等。

## 16. 错误处理

ADK-Go 框架使用标准的 Go 错误处理机制，通过返回 error 类型来表示错误。框架提供了一些自定义错误类型，用于表示特定的错误情况：

### 16.1 AgentError 类型

```go
type AgentError struct {
    Message string
    Code    string
    Cause   error
}
```

**描述**：
AgentError 表示代理相关的错误。

**方法说明**：
- `Error() string`：返回错误信息
- `Unwrap() error`：返回底层错误

### 16.2 NewAgentError 函数

```go
func NewAgentError(message, code string, cause error) error
```

**描述**：
创建一个新的代理错误。

**参数**：
- `message`：错误信息
- `code`：错误代码
- `cause`：底层错误

**返回值**：
- `error`：创建的错误

## 17. 日志

ADK-Go 框架使用标准的 Go 日志包进行日志记录。您可以通过环境变量或代码配置日志级别：

### 17.1 配置日志级别

```bash
# 通过环境变量设置
export ADK_LOG_LEVEL="debug"

# 或者在代码中设置
log.SetLevel(log.DebugLevel)
```

### 17.2 日志级别

ADK-Go 支持以下日志级别：

- `debug`：详细的调试信息
- `info`：普通信息
- `warn`：警告信息
- `error`：错误信息
- `fatal`：致命错误信息

## 18. 配置

ADK-Go 框架支持通过环境变量或配置文件进行配置：

### 18.1 环境变量

| 环境变量 | 描述 | 默认值 |
|----------|------|--------|
| GOOGLE_API_KEY | Gemini API 密钥 | 无 |
| ADK_APP_NAME | 应用名称 | adk-app |
| ADK_LOG_LEVEL | 日志级别 | info |
| ADK_PORT | 应用端口 | 8080 |
| ADK_STORAGE_TYPE | 存储类型（memory、file、cloud） | memory |
| ADK_FILE_STORAGE_PATH | 文件存储路径 | ./data |

### 18.2 配置文件

您可以使用 YAML 或 JSON 格式的配置文件来配置 ADK-Go 应用：

```yaml
app_name: "my-adk-app"
log_level: "info"
port: 8080
storage:
  type: "file"
  path: "./data"
model:
  name: "gemini-1.5-pro"
instruction: "You are a helpful assistant."
```

## 19. 最佳实践

### 19.1 API 使用最佳实践

- **使用适当的代理类型**：根据任务需求选择合适的代理类型，如 LLM 代理、工作流代理或远程代理

- **合理配置代理**：根据任务需求配置代理参数，如温度、TopP、TopK 等

- **使用适当的工具**：为代理提供必要的工具，避免过多无用工具

- **实现适当的错误处理**：处理代理运行过程中可能出现的错误

- **监控代理运行**：监控代理的运行状态和性能指标

### 19.2 代码组织最佳实践

- **模块化设计**：将复杂代理分解为多个简单代理

- **清晰的命名**：为代理、工具和变量使用清晰、描述性的名称

- **适当的注释**：为代码添加适当的注释，说明代理的功能和行为

- **测试驱动开发**：为代理和工具编写单元测试，确保其正确性

## 20. 版本兼容性

ADK-Go 框架遵循语义化版本控制（SemVer），版本号格式为 `MAJOR.MINOR.PATCH`：

- **MAJOR**：不兼容的 API 变更
- **MINOR**：向后兼容的功能新增
- **PATCH**：向后兼容的问题修复

在升级 ADK-Go 版本时，请注意以下几点：

- 升级 MAJOR 版本时，可能需要修改代码以适应新的 API
- 升级 MINOR 或 PATCH 版本时，代码应该可以直接运行，不需要修改

## 21. 常见问题

### 21.1 如何创建自定义代理？

您可以使用 `agent.New` 函数创建自定义代理，实现自己的 Run 函数：

```go
myAgent, _ := agent.New(agent.Config{
    Name:        "my-custom-agent",
    Description: "A simple custom agent",
    Run: func(ctx agent.InvocationContext) iter.Seq2[*session.Event, error] {
        return func(yield func(*session.Event, error) bool) {
            event := session.NewEvent(ctx.InvocationID())
            event.Content = genai.NewContentFromText("Hello from custom agent!")
            event.Author = ctx.Agent().Name()
            yield(event, nil)
        }
    },
})
```

### 21.2 如何使用自定义工具？

您可以实现 `tool.Tool` 接口来创建自定义工具：

```go
type MyTool struct{}

func (t *MyTool) Name() string {
    return "my-tool"
}

func (t *MyTool) Description() string {
    return "A simple custom tool"
}

func (t *MyTool) IsLongRunning() bool {
    return false
}

func (t *MyTool) Invoke(ctx context.Context, args json.RawMessage) (any, error) {
    return map[string]any{"result": "Tool result"}, nil
}
```

然后将工具添加到代理配置中：

```go
llmAgent, _ := llmagent.New(llmagent.Config{
    Name:    "llm-agent-with-tools",
    Model:   "gemini-1.5-pro",
    Tools:   []tool.Tool{&MyTool{}},
})
```

### 21.3 如何部署 ADK-Go 应用？

ADK-Go 支持多种部署方式，包括本地部署、容器化部署、云原生部署和 Kubernetes 部署。请参考 [ADK-Go 部署指南](ADK-Go部署指南.md) 了解详细信息。

## 22. 总结

本 API 参考文档提供了 ADK-Go 框架的核心 API 信息，包括主要接口、结构体、函数和方法。通过了解这些 API，您可以更好地使用 ADK-Go 框架开发自己的代理应用。

对于更详细的信息，建议查看 ADK-Go 源代码和其他文档，如 [ADK-Go 开发指南](ADK-Go开发指南.md)、[ADK-Go 架构设计文档](ADK-Go架构设计文档.md) 和 [ADK-Go 示例库详解](ADK-Go示例库详解.md)。
